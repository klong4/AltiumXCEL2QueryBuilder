#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
import pandas as pd
from models.rule_model import RuleManager

class RuleGeneratorError(Exception):
    """Custom exception class for RuleGenerator errors."""

    def __init__(self, message: str):
        """
        Initializes the RuleGeneratorError.

        Args:
            message (str): Error message to be displayed.
        """
        super().__init__(message)
        logging.error(message)

class RuleGenerator:
    """Generates Altium Designer rule files (.RUL) from structured data."""

    def __init__(self, rule_manager: RuleManager):
        """
        Initializes the RuleGenerator.

        Args:
            rule_manager (RuleManager): The manager containing the rule data.
        """
        self.rule_manager = rule_manager

    def generate_rul_content(self, rules_data: List[Dict[str, Any]]) -> str:
        """
        Generates the content for the .RUL file based on the provided rules data.

        Args:
            rules_data (List[Dict[str, Any]]): A list of dictionaries, each representing a rule.
                                                Expected keys: 'Name', 'Priority', 'Enabled',
                                                'Object Scope 1', 'Object Type 1',
                                                'Object Scope 2', 'Object Type 2',
                                                'Operator', 'Value', 'Unit', 'Comment'.

        Returns:
            str: The generated content for the .RUL file.
        """
        rul_lines = []
        header = f"""// Altium Designer Rule File
// Generated by AltiumXCEL2QueryBuilder on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// Source Data: In-memory data

"""
        rul_lines.append(header)

        for rule in rules_data:
            try:
                name = rule.get('Name', 'UnnamedRule')
                priority = rule.get('Priority', 1)
                enabled = rule.get('Enabled', True)
                scope1 = rule.get('Object Scope 1', 'All')
                type1 = rule.get('Object Type 1', '')
                scope2 = rule.get('Object Scope 2', 'All')
                type2 = rule.get('Object Type 2', '')
                operator = rule.get('Operator', '>')
                value = rule.get('Value', 0)
                unit = rule.get('Unit', 'mm')
                comment = rule.get('Comment', '')

                # Basic validation/sanitization (can be expanded)
                name = ''.join(c for c in name if c.isalnum() or c in ['_', '-'])
                priority = int(priority) if str(priority).isdigit() else 1
                enabled_str = 'True' if enabled else 'False'
                value_str = str(value) # Keep as string for flexibility

                # Construct the query string
                query = f"({type1} = '{scope1}') {operator} ({type2} = '{scope2}')"
                if type1 and not scope1: query = f"Is{type1}"
                if type2 and not scope2: query = f"Is{type2}"
                if type1 and scope1 and type2 and scope2:
                     query = f"({type1} = '{scope1}') {operator} ({type2} = '{scope2}')" # Default case
                elif type1 and scope1:
                     query = f"({type1} = '{scope1}')"
                elif type2 and scope2:
                     query = f"({type2} = '{scope2}')"
                else:
                     query = "All" # Fallback if scopes/types are missing


                # Format the rule entry
                rule_entry = f"""Rule[{len(rul_lines)}]
	Name={name}
	Priority={priority}
	Enabled={enabled_str}
	Comment={comment}
	RuleKind=ClearanceConstraint""" # Assuming ClearanceConstraint for now

                # Add specific constraint details based on operator/value/unit
                # This part needs refinement based on Altium's exact RUL format for different constraints
                # Example for a simple clearance rule:
                rule_entry += f"""
	Object Scope 1={scope1}
	Object Type 1={type1}
	Object Scope 2={scope2}
	Object Type 2={type2}
	Operator={operator}
	Value={value_str}{unit}""" # Combine value and unit

                # Add the full query string
                rule_entry += f"""
	Full Query={query}
EndRule[{len(rul_lines)}]

"""
                rul_lines.append(rule_entry)

            except Exception as e:
                logging.error(f"Error processing rule '{rule.get('Name', 'N/A')}': {e}")
                # Optionally skip the rule or add a placeholder comment

        return "".join(rul_lines)


    def generate_and_save_rul(self, output_path: str, rules_data: Optional[List[Dict[str, Any]]] = None):
        """
        Generates the .RUL file content and saves it to the specified path.

        Args:
            output_path (str): The full path where the .RUL file should be saved.
            rules_data (Optional[List[Dict[str, Any]]]): The rule data to use.
                                                        If None, uses data from the rule_model.
        """
        if rules_data is None:
            rules_data = self.rule_manager.to_dict() # Changed rule_model.get_all_rules_as_dicts() to rule_manager.to_dict()

        if not rules_data:
            logging.warning("No rules data provided or found in the model. Cannot generate RUL file.")
            return

        rul_content = self.generate_rul_content(rules_data)

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(rul_content)
            logging.info(f"Successfully generated and saved RUL file to: {output_path}")
        except IOError as e:
            logging.error(f"Error saving RUL file to {output_path}: {e}")
            raise # Re-raise the exception for the caller to handle

    def generate_from_dataframe(self, df: pd.DataFrame) -> str:
         """
         Generates RUL content directly from a pandas DataFrame.

         Args:
             df (pd.DataFrame): DataFrame containing the rule data.
                                Expected columns match the keys in generate_rul_content.

         Returns:
             str: The generated content for the .RUL file.
         """
         # Convert DataFrame rows to list of dictionaries
         rules_data = df.to_dict('records')
         return self.generate_rul_content(rules_data)
